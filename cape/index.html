<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minecraft Cape Maker</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-950 text-gray-100 font-sans min-h-screen flex flex-col">
  <header class="text-center py-12 bg-gradient-to-r from-green-700 to-emerald-500 shadow-xl">
    <h1 class="text-4xl md:text-6xl font-extrabold drop-shadow-lg">Minecraft Cape Maker</h1>
    <p class="mt-3 text-lg md:text-xl">Design custom capes for ITTA</p>
  </header>

  <main class="flex-1 max-w-4xl mx-auto p-6">
    <div class="bg-gray-900 rounded-2xl p-6 shadow-xl border border-gray-800 text-center">
      <div class="mx-auto mb-6 inline-block rounded-lg border border-gray-700 shadow-lg"
           style="background-image:
                   linear-gradient(45deg,#0f0f0f 25%, transparent 25%),
                   linear-gradient(-45deg,#0f0f0f 25%, transparent 25%),
                   linear-gradient(45deg,transparent 75%,#141414 75%),
                   linear-gradient(-45deg,transparent 75%,#141414 75%);
                  background-size: 16px 16px;
                  background-position: 0 0, 0 8px, 8px -8px, -8px 0px;">
        <canvas id="editor" style="image-rendering: pixelated; display:block; border-radius: 0.5rem;"></canvas>
      </div>

      <div id="toolbar" class="flex flex-wrap justify-center items-center gap-3 mb-4">
        <div class="flex items-center bg-gray-800 border border-gray-700 rounded-lg p-2 shadow-inner">
          <button id="openPicker" class="tool-btn inline-flex items-center gap-2 bg-emerald-600 hover:bg-emerald-700 text-sm px-3 py-2 rounded-lg font-semibold transition"
                  aria-pressed="false">üé® Picker</button>
          <input id="hexInput" class="ml-2 w-24 bg-gray-900 border border-gray-700 rounded-md text-center uppercase focus:outline-none focus:ring-2 focus:ring-emerald-500"
                 type="text" maxlength="7" value="#FFCC00" aria-label="hex color" />
        </div>
        <button id="pencilBtn" class="tool-btn" data-tool="pencil">‚úè Pencil</button>
        <button id="eraserBtn" class="tool-btn" data-tool="eraser">ü©π Eraser</button>
        <button id="dropperBtn" class="tool-btn" data-tool="dropper">üéØ Eyedropper</button>
        <button id="clearBtn" class="px-4 py-2 rounded-xl font-semibold transition bg-red-600 hover:bg-red-700" title="Clear canvas">Clear</button>
        <button id="exportBtn" class="px-4 py-2 rounded-xl font-semibold transition bg-blue-600 hover:bg-blue-700" title="Export PNG">Export PNG</button>
      </div>
      <div class="mt-2 flex items-center justify-center gap-2">
        <div class="text-sm text-gray-400 mr-2">Recent:</div>
        <div id="recentContainer" class="flex gap-2 items-center"></div>
      </div>
      <div class="text-left bg-gray-800 p-4 rounded-xl border border-gray-700 max-w-md mx-auto text-sm leading-relaxed mt-4">
        <p class="font-semibold mb-2 text-center">Template Key:</p>
        <p><span class="text-blue-400 font-semibold">Blue</span> = Front</p>
        <p><span class="text-red-400 font-semibold">Red</span> = Back</p>
        <p><span class="text-green-400 font-semibold">Green</span> = Left / Right</p>
        <p><span class="text-orange-400 font-semibold">Orange</span> = Top</p>
        <p><span class="text-yellow-400 font-semibold">Yellow</span> = Bottom</p>
      </div>

    </div>
  </main>

  <div id="toast" class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-emerald-600 text-white px-6 py-3 rounded-xl shadow-lg opacity-0 transition-opacity duration-500 pointer-events-none z-50">
  </div>

  <div id="colorModal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4">
    <div class="bg-gray-900 rounded-2xl p-5 w-full max-w-3xl md:max-w-4xl border border-gray-700 shadow-xl overflow-hidden">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-bold">Color Wheel</h2>
        <button id="closePicker" class="text-sm px-3 py-1 rounded-md bg-gray-800 hover:bg-gray-700">Close</button>
      </div>

      <div class="flex flex-wrap gap-4">
        <canvas id="wheel" width="320" height="320" class="rounded-md border border-gray-700"></canvas>

        <div class="flex-1 min-w-[220px]">
          <div id="preview" class="w-full h-24 rounded-md border border-gray-700 mb-3 flex items-center justify-center">
            <div id="previewSwatch" class="w-20 h-20 rounded-md border border-gray-600"></div>
          </div>

          <label class="block text-sm text-gray-300 mb-1">Brightness</label>
          <input id="brightness" type="range" min="0" max="100" value="100" class="w-full mb-3 accent-emerald-500">

          <div class="flex items-center justify-between gap-3">
            <button id="applyPicker" class="flex-1 bg-emerald-600 hover:bg-emerald-700 px-4 py-2 rounded-xl font-semibold">Apply</button>
            <button id="resetRecent" class="px-3 py-2 rounded-lg bg-gray-800 hover:bg-gray-700 text-sm">Reset Recent</button>
          </div>

          <div class="mt-3">
            <div class="text-xs text-gray-400 mb-1">Recent colors</div>
            <div id="recentModal" class="flex gap-2 flex-wrap"></div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <footer class="text-center py-6 text-gray-500 text-sm border-t border-gray-800">
    &copy; 2025 Idiots Through The Ages ‚Äî Minecraft Server Project<br>
    Cape Maker by Lumisere
  </footer>

  <script>

  const WIDTH = 64, HEIGHT = 32;
  const scale = 20;
  const minX = 0, maxX = 21, minY = 0, maxY = 16;
  const visibleW = maxX - minX + 1, visibleH = maxY - minY + 1;

  const canvas = document.getElementById('editor');
  const ctx = canvas.getContext('2d');
  canvas.width = visibleW * scale;
  canvas.height = visibleH * scale;
  canvas.style.width = (visibleW * scale) + 'px';
  canvas.style.height = (visibleH * scale) + 'px';
  canvas.style.imageRendering = 'pixelated';
  canvas.tabIndex = 0;
  let grid = Array.from({length: HEIGHT}, () => Array.from({length: WIDTH}, () => [0,0,0,0]));


  const WATERMARK = [{x:63,y:31},{x:63,y:30},{x:63,y:28},{x:61,y:23},{x:61,y:24},{x:61,y:25},{x:61,y:26},{x:62,y:26},{x:63,y:26},{x:63,y:25},{x:63,y:24},{x:63,y:23},{x:59,y:26},{x:58,y:26},{x:57,y:26},{x:57,y:25},{x:57,y:24},{x:57,y:23},{x:57,y:28},{x:57,y:29},{x:57,y:30},{x:57,y:31},{x:58,y:29},{x:59,y:30},{x:60,y:29},{x:61,y:28},{x:61,y:29},{x:61,y:30},{x:61,y:31}];
  const WATERMARK_COLOR = [0,255,249,255];
  function applyWatermark(){ for(const p of WATERMARK){ if(p.x>=0&&p.x<WIDTH&&p.y>=0&&p.y<HEIGHT) grid[p.y][p.x] = WATERMARK_COLOR.slice(); } }

  function isEditable(x,y){
    return (
      (y===0 && x>=1 && x<=10) || (y===0 && x>=11 && x<=20) ||
      (x>=1 && x<=10 && y>=1 && y<=16) || (x>=12 && x<=21 && y>=1 && y<=16) ||
      ((x===0||x===11)&&y>=1&&y<=16)
    );
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for(let y=minY;y<=maxY;y++){
      for(let x=minX;x<=maxX;x++){
        const [r,g,b,a] = grid[y][x];
        ctx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
        ctx.fillRect((x-minX)*scale,(y-minY)*scale,scale,scale);
      }
    }

    ctx.globalAlpha = 0.25;
    for(let y=minY;y<=maxY;y++){
      for(let x=minX;x<=maxX;x++){
        if(!isEditable(x,y)) continue;
        const [r,g,b,a] = grid[y][x];
        if(a !== 0) continue;
        if (y===0 && x>=1 && x<=10) ctx.fillStyle = "#f80";
        else if (y===0 && x>=11 && x<=21) ctx.fillStyle = "#ff4";
        else if (x>=1 && x<=10 && y>=1 && y<=16) ctx.fillStyle = "#44f";
        else if (x>=12 && x<=21 && y>=1 && y<=16) ctx.fillStyle = "#f44";
        else if ((x===0 || x===11) && y>=1 && y<=16) ctx.fillStyle = "#4f4";
        ctx.fillRect((x-minX)*scale,(y-minY)*scale,scale,scale);
      }
    }
    ctx.globalAlpha = 1;

    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    for(let x=0;x<=visibleW;x++){
      ctx.beginPath(); ctx.moveTo(x*scale+0.5,0); ctx.lineTo(x*scale+0.5,visibleH*scale); ctx.stroke();
    }
    for(let y=0;y<=visibleH;y++){
      ctx.beginPath(); ctx.moveTo(0,y*scale+0.5); ctx.lineTo(visibleW*scale,y*scale+0.5); ctx.stroke();
    }
  }

  function hexToRgba(hex){
    const h = hex.replace('#','');
    const n = parseInt(h,16);
    return [(n>>16)&255, (n>>8)&255, n&255, 255];
  }
  function rgbaToHex(r,g,b){ return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('').toUpperCase(); }
  function hexToRgbArr(hex){
    const h = hex.replace('#','');
    const n = parseInt(h,16);
    return [(n>>16)&255, (n>>8)&255, n&255];
  }
  function setPixel(x,y,color){
    if(!isEditable(x,y)) return;
    if(WATERMARK.some(p=>p.x===x&&p.y===y)) return;
    grid[y][x] = color;
  }

  function erasePixel(x,y){ if(!isEditable(x,y)) return; if(WATERMARK.some(p=>p.x===x&&p.y===y)) return; grid[y][x] = [0,0,0,0]; }
  function clearEditable(){
    for(let y=0;y<HEIGHT;y++){
      for(let x=0;x<WIDTH;x++){
        if(isEditable(x,y)) grid[y][x] = [0,0,0,0];
      }
    }
    applyWatermark();
    draw();
  }


  applyWatermark();
  draw();

  let tool = 'pencil';
  let currentColor = '#FFCC00';
  const hexInput = document.getElementById('hexInput');
  const toast = document.getElementById('toast');

  const toolButtons = {
    pencil: document.getElementById('pencilBtn'),
    eraser: document.getElementById('eraserBtn'),
    dropper: document.getElementById('dropperBtn'),
  };

  function setupToolButtons(){
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.classList.add('px-4','py-2','rounded-xl','font-semibold','transition','transform','bg-gray-700','hover:bg-gray-600');
    });
    document.getElementById('clearBtn').classList.remove('bg-gray-700'); document.getElementById('clearBtn').classList.add('bg-red-600','hover:bg-red-700');
    document.getElementById('exportBtn').classList.remove('bg-gray-700'); document.getElementById('exportBtn').classList.add('bg-blue-600','hover:bg-blue-700');
    refreshToolUI();
  }

  function refreshToolUI(){
    Object.values(toolButtons).forEach(b => {
      b.classList.remove('ring-2','ring-emerald-500','scale-105');
      b.setAttribute('aria-pressed','false');
      if(!b.classList.contains('bg-emerald-600')&&!b.classList.contains('bg-red-600')&&!b.classList.contains('bg-blue-600')){
        b.classList.add('bg-gray-700'); b.classList.add('hover:bg-gray-600');
      }
    });
    if(toolButtons[tool]){
      const b = toolButtons[tool];
      b.classList.remove('bg-gray-700'); b.classList.remove('hover:bg-gray-600');
      b.classList.add('ring-2','ring-emerald-500','scale-105');
      b.setAttribute('aria-pressed','true');
    }
  }

  setupToolButtons();

  function setTool(t){
    tool = t;
    refreshToolUI();
    hexInput.blur();
  }

  document.querySelectorAll('[data-tool]').forEach(btn => {
    btn.addEventListener('click', () => setTool(btn.getAttribute('data-tool')));
  });

  let drawing = false;
  canvas.addEventListener('mousedown', e => { drawing = true; handlePointer(e); });
  canvas.addEventListener('mousemove', e => { if(drawing) handlePointer(e); });
  canvas.addEventListener('mouseup', () => drawing = false);
  canvas.addEventListener('mouseleave', () => drawing = false);

  function getCanvasCoords(e){
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / scale) + minX;
    const y = Math.floor((e.clientY - rect.top) / scale) + minY;
    return {x,y};
  }

  function handlePointer(e){
    const {x,y} = getCanvasCoords(e);
    if(x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;

    if(tool === 'pencil'){
      setPixel(x,y, hexToRgba(currentColor));
    } else if(tool === 'eraser'){
      erasePixel(x,y);
    } else if(tool === 'dropper'){
      const [r,g,b,a] = grid[y][x];
      if(a === 0){
        showToast('No color here ‚Äî try a painted pixel');
      } else {
        currentColor = rgbaToHex(r,g,b);
        hexInput.value = currentColor;
        updatePickerPreviewFromHex(currentColor, false);
        setTool('pencil');
      }
    }
    applyWatermark();
    draw();
  }

  function exportPNG(){
    const tmp = document.createElement('canvas');
    tmp.width = WIDTH; tmp.height = HEIGHT;
    const c = tmp.getContext('2d');
    const img = c.createImageData(WIDTH, HEIGHT);
    for(let y=0;y<HEIGHT;y++){
      for(let x=0;x<WIDTH;x++){
        const i = (y*WIDTH + x) * 4;
        if(!isEditable(x,y)){
          img.data[i] = 0; img.data[i+1] = 0; img.data[i+2] = 0; img.data[i+3] = 255;
        } else {
          const [r,g,b,a] = grid[y][x];
          if(a === 0){
            img.data[i] = 0; img.data[i+1] = 0; img.data[i+2] = 0; img.data[i+3] = 255;
          } else {
            img.data[i] = r; img.data[i+1] = g; img.data[i+2] = b; img.data[i+3] = a;
          }
        }
      }
    }
    for(const p of WATERMARK){
      const i = (p.y*WIDTH + p.x) * 4;
      img.data[i] = WATERMARK_COLOR[0]; img.data[i+1] = WATERMARK_COLOR[1]; img.data[i+2] = WATERMARK_COLOR[2]; img.data[i+3] = WATERMARK_COLOR[3];
    }
    c.putImageData(img,0,0);
    const url = tmp.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = 'cape.png'; a.click();
    showToast('‚úÖ Cape exported as cape.png!');
  }

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.remove('opacity-0'); toast.classList.add('opacity-100');
    setTimeout(()=>{ toast.classList.replace('opacity-100','opacity-0'); }, 2500);
  }

  document.getElementById('clearBtn').addEventListener('click', () => {
    clearEditable();
    showToast('Canvas cleared');
  });
  document.getElementById('exportBtn').addEventListener('click', exportPNG);

  const wheel = document.getElementById('wheel');
  const wctx = wheel.getContext('2d');
  const wheelSize = wheel.width;
  const wheelCx = wheelSize/2, wheelCy = wheelSize/2;
  const wheelRadius = wheelSize/2 - 1;
  const brightnessSlider = document.getElementById('brightness');
  const previewSwatch = document.getElementById('previewSwatch');

  const RECENT_KEY = 'capeMakerRecentColors_v1';
  let recentColors = loadRecentColors();
  const recentContainer = document.getElementById('recentContainer');
  const recentModal = document.getElementById('recentModal');

  function loadRecentColors(){
    try{
      const raw = localStorage.getItem(RECENT_KEY);
      if(!raw) return ['#FFCC00'];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) && arr.length ? arr.slice(0,10) : ['#FFCC00'];
    } catch(e){
      return ['#FFCC00'];
    }
  }
  function saveRecentColors(){
    localStorage.setItem(RECENT_KEY, JSON.stringify(recentColors.slice(0,10)));
    renderRecent();
  }
  function pushRecent(hex){
    hex = hex.toUpperCase();
    recentColors = recentColors.filter(c => c !== hex);
    recentColors.unshift(hex);
    recentColors = recentColors.slice(0,10);
    saveRecentColors();
  }

  function renderRecent(){
    recentContainer.innerHTML = ''; recentModal.innerHTML = '';
    for(const hex of recentColors){
      const s = document.createElement('button');
      s.className = 'w-7 h-7 rounded-md border border-gray-700 shadow-sm';
      s.style.background = hex;
      s.title = hex;
      s.onclick = () => { currentColor = hex; hexInput.value = hex; updatePickerPreviewFromHex(hex); };
      recentContainer.appendChild(s);

      const m = s.cloneNode(true);
      m.onclick = () => { currentColor = hex; hexInput.value = hex; updatePickerPreviewFromHex(hex); };
      recentModal.appendChild(m);
    }
  }

  function hsvToRgb(h, s, v){
    const c = v * s;
    const hh = h / 60;
    const x = c * (1 - Math.abs(hh % 2 - 1));
    let r=0,g=0,b=0;
    if(hh>=0 && hh<1){ r=c; g=x; b=0; }
    else if(hh<2){ r=x; g=c; b=0; }
    else if(hh<3){ r=0; g=c; b=x; }
    else if(hh<4){ r=0; g=x; b=c; }
    else if(hh<5){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    const m = v - c;
    return [Math.round((r+m)*255), Math.round((g+m)*255), Math.round((b+m)*255)];
  }
  function rgbToHsv(r,g,b){
    r/=255; g/=255; b/=255;
    const mx = Math.max(r,g,b), mn = Math.min(r,g,b);
    const d = mx - mn;
    let h = 0;
    if(d === 0) h = 0;
    else if(mx === r) h = 60 * (((g - b) / d) % 6);
    else if(mx === g) h = 60 * (((b - r) / d) + 2);
    else h = 60 * (((r - g) / d) + 4);
    if(h < 0) h += 360;
    const s = mx === 0 ? 0 : d / mx;
    const v = mx;
    return [h, s, v];
  }

  function drawWheel(){
    const img = wctx.createImageData(wheelSize, wheelSize);
    for(let y=0;y<wheelSize;y++){
      for(let x=0;x<wheelSize;x++){
        const dx = x - wheelCx;
        const dy = y - wheelCy;
        const d = Math.sqrt(dx*dx + dy*dy);
        const i = (y*wheelSize + x) * 4;
        if(d <= wheelRadius){
          let hue = (Math.atan2(dy,dx) * 180/Math.PI + 360) % 360;
          let sat = Math.min(1, d / wheelRadius);
          const bright = brightnessSlider.value/100;
          const [r,g,b] = hsvToRgb(hue, sat, bright);
          img.data[i] = r; img.data[i+1] = g; img.data[i+2] = b; img.data[i+3] = 255;
        } else {
          img.data[i] = 0; img.data[i+1] = 0; img.data[i+2] = 0; img.data[i+3] = 0;
        }
      }
    }
    wctx.putImageData(img, 0, 0);
    wctx.beginPath();
    wctx.arc(wheelCx, wheelCy, wheelRadius+0.5, 0, Math.PI*2);
    wctx.strokeStyle = 'rgba(255,255,255,0.06)';
    wctx.lineWidth = 1;
    wctx.stroke();
  }

  let wheelPicking = false;
  function wheelPointerHandler(e){
    const rect = wheel.getBoundingClientRect();
    const x = Math.round(e.clientX - rect.left);
    const y = Math.round(e.clientY - rect.top);
    const dx = x - wheelCx, dy = y - wheelCy;
    const d = Math.sqrt(dx*dx + dy*dy);
    if(d > wheelRadius) return;
    let hue = (Math.atan2(dy,dx) * 180/Math.PI + 360) % 360;
    let sat = Math.min(1, d / wheelRadius);
    const bright = brightnessSlider.value / 100;
    const [r,g,b] = hsvToRgb(hue, sat, bright);
    const hex = rgbaToHex(r,g,b);
    currentColor = hex;
    hexInput.value = hex;
    updatePickerPreviewFromHex(hex, false);
  }
  wheel.addEventListener('mousedown', e => { wheelPicking = true; wheelPointerHandler(e); });
  window.addEventListener('mousemove', e => { if(wheelPicking) wheelPointerHandler(e); });
  window.addEventListener('mouseup', () => wheelPicking = false);
  wheel.addEventListener('click', wheelPointerHandler);

  brightnessSlider.addEventListener('input', () => {
    drawWheel();
    const [r,g,b] = hexToRgbArr(currentColor);
    const [h,s,_v] = rgbToHsv(r,g,b);
    const [rr,gg,bb] = hsvToRgb(h, s, brightnessSlider.value/100);
    previewSwatch.style.background = rgbaToHex(rr,gg,bb);
  });

  function updatePickerPreviewFromHex(hex, pushRecentFlag=true){
    const [r,g,b] = hexToRgbArr(hex);
    const [h,s,v] = rgbToHsv(r,g,b);
    const [rr,gg,bb] = hsvToRgb(h, s, brightnessSlider.value/100);
    const hexDisplayed = rgbaToHex(rr,gg,bb);
    previewSwatch.style.background = hexDisplayed;
    currentColor = hex.toUpperCase();
    hexInput.value = currentColor;
    if(pushRecentFlag) pushRecent(currentColor);
  }

  document.getElementById('openPicker').addEventListener('click', () => {
    drawWheel();
    updatePickerPreviewFromHex(currentColor, false);
    document.getElementById('colorModal').classList.remove('hidden');
  });
  document.getElementById('closePicker').addEventListener('click', () => {
    document.getElementById('colorModal').classList.add('hidden');
  });
  document.getElementById('applyPicker').addEventListener('click', () => {
    pushRecent(currentColor);
    document.getElementById('colorModal').classList.add('hidden');
  });
  document.getElementById('resetRecent').addEventListener('click', () => {
    recentColors = ['#FFCC00'];
    saveRecentColors();
  });

  hexInput.addEventListener('input', (e) => {
    let v = e.target.value.trim().toUpperCase();
    if(!v.startsWith('#')) v = '#' + v;
    if(/^#[0-9A-F]{6}$/.test(v)){
      currentColor = v;
      updatePickerPreviewFromHex(currentColor, false);
    }
  });

  renderRecent();
  drawWheel();
  saveRecentColors();
  updatePickerPreviewFromHex(currentColor, false);

  if(!localStorage.getItem('capeMaker_seen_hint')){
    showToast('Tip: Click üé® Picker for the color wheel. Use üéØ to sample painted pixels.');
    localStorage.setItem('capeMaker_seen_hint','1');
  }

  window.addEventListener('resize', () => {
    canvas.style.width = (visibleW * scale) + 'px';
    canvas.style.height = (visibleH * scale) + 'px';
  });

  </script>
</body>
</html>
